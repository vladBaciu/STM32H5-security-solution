/**
  ******************************************************************************
  * @file    crypto.c
  * @author  MCD Application Team
  * @brief   NS CRYPTO program
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2023 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */

/* Includes ------------------------------------------------------------------*/
#include "com.h"
#include "cryp.h"
#include "crypto_tests_common.h"

/* Private typedef -----------------------------------------------------------*/
/* Private define ------------------------------------------------------------*/
/* Private macro -------------------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/
/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/
static void FW_APP_CRYPTO_PrintMenu(void);
static void FW_APP_CRYPTO_DisplayAead(void);
static void FW_APP_CRYPTO_EcdsaSignMsg(psa_key_id_t id_key);

/**
  * @brief  Display the CRYPTO Menu choices on HyperTerminal
  * @param  None.
  * @retval None.
  */
static void FW_APP_CRYPTO_PrintMenu(void)
{
  (void)printf("\r\n=================== Cryptography Menu ====================\r\n\r\n");
  (void)printf("  RNG -------------------------------------------------- 1\r\n\r\n");
#ifdef TFM_CRYPTO_TEST_ALG_GCM
  (void)printf("  AES GCM ---------------------------------------------- 2\r\n\r\n");
#endif /* GCM */
#ifdef TFM_CRYPTO_TEST_ALG_CBC
  (void)printf("  AES CBC ---------------------------------------------- 3\r\n\r\n");
#endif /* CBC */
#ifdef TFM_CRYPTO_TEST_ALG_CCM
  (void)printf("  AES CCM ---------------------------------------------- 4\r\n\r\n");
#endif /* CCM */
  (void)printf("  SHA224 ----------------------------------------------- 5\r\n\r\n");
  (void)printf("  SHA256 ----------------------------------------------- 6\r\n\r\n");
  (void)printf("  RSA 2048 --------------------------------------------- 7\r\n\r\n");
  (void)printf("  ECDSA (DUA USER key) --------------------------------- 8\r\n\r\n");
  (void)printf("  ECDSA (Factory ITS key) ------------------------------ 9\r\n\r\n");
  (void)printf("  Previous menu ---------------------------------------- x\r\n\r\n");
  (void)printf("  Selection :\r\n\r\n");
  (void)printf("  ");
}

/**
  * @brief  Run the CRYPTO example
            In each test, the PSA API used are display
  * @param  None.
  * @retval None.
  */
void FW_APP_CRYPTO_Run(void)
{
  uint8_t key = 0U;
  uint8_t exit = 0U;

  struct test_result_t ret;

  psa_status_t psa_status = PSA_ERROR_GENERIC_ERROR;
  size_t size = 16U;
  uint8_t output[16] = {0};

  /* Print Menu message*/
  FW_APP_CRYPTO_PrintMenu();

  while (exit == 0U)
  {
    /* Clean the input path */
    (void)COM_Flush();

    /* Receive key */
    if (COM_Receive(&key, 1U, RX_TIMEOUT) == HAL_OK)
    {
      (void)printf("%c\r\n", key);
      switch (key)
      {
        case '1' :
          /* Display random generated by psa api */
          (void)printf("\nPSA API tested : \r\n\r\n");
          (void)printf("psa_generate_random() \r\n");
          psa_status = psa_generate_random(output, size);
          if (psa_status == PSA_SUCCESS)
          {
            (void)printf("\r\nTEST PASSED\r\n");
            (void)printf("\nRandom generated (size 0x%x):\r\n", size);
            for (uint32_t i = 0; i < size; i++)
            {
              (void)printf("%x ", output[i]);
            }
            (void)printf("\r\n");
          }
          else
          {
            (void)printf("\nTEST FAILED : %d \r\n", (int)psa_status);
          }
          break;
#ifdef TFM_CRYPTO_TEST_ALG_GCM
        case '2' :
          /* Display PSA API called in the test GCM */
          FW_APP_CRYPTO_DisplayAead();
          /* Test AES GCM with key test of 128 bits */
          psa_aead_test(PSA_KEY_TYPE_AES, PSA_ALG_GCM,
                        test_key_128, BIT_SIZE_TEST_KEY, &ret);
          (void)printf("\r\n%s\r\n", ret.info_msg);
          break;
#endif /* GCM */

#ifdef TFM_CRYPTO_TEST_ALG_CBC
        case '3' :
          /* Display PSA API called in the test CBC */
          (void)printf("\nPSA API tested : \r\n\r\n");
          (void)printf("psa_cipher_operation_init() \r\n");
          (void)printf("psa_key_attributes_init() \r\n");
          (void)printf("psa_set_key_usage_flags() \r\n");
          (void)printf("psa_set_key_algorithm() \r\n");
          (void)printf("psa_set_key_type() \r\n");
          (void)printf("psa_set_key_lifetime() \r\n");
          (void)printf("psa_import_key() \r\n");
          (void)printf("psa_get_key_attributes() \r\n");
          (void)printf("psa_get_key_bits() \r\n");
          (void)printf("psa_get_key_type() \r\n");
          (void)printf("psa_reset_key_attributes() \r\n");
          (void)printf("psa_cipher_encrypt() \r\n");
          (void)printf("psa_cipher_decrypt() \r\n");
          (void)printf("psa_cipher_encrypt_setup() \r\n");
          (void)printf("psa_cipher_set_iv() \r\n");
          (void)printf("psa_cipher_update() \r\n");
          (void)printf("psa_cipher_finish() \r\n");
          (void)printf("psa_cipher_decrypt_setup() \r\n");
          /* Test AES CBC with key test of 128 bits */
          psa_cipher_test(PSA_KEY_TYPE_AES, PSA_ALG_CBC_NO_PADDING,
                          test_key_128, BIT_SIZE_TEST_KEY, &ret);
          (void)printf("\r\n%s\r\n", ret.info_msg);
          break;
#endif /* CBC */

#ifdef TFM_CRYPTO_TEST_ALG_CCM
        case '4' :
          /* Display PSA API called in the test CCM */
          FW_APP_CRYPTO_DisplayAead();
          /* Test AES CCM with key test of 128 bits */
          psa_aead_test(PSA_KEY_TYPE_AES, PSA_ALG_CCM,
                        test_key_128, BIT_SIZE_TEST_KEY, &ret);
          (void)printf("\r\n%s\r\n", ret.info_msg);
          break;
#endif /* CCM */

        case '5' :
          /* Test SHA 224 */
          (void)printf("\nPSA API tested : \r\n\r\n");
          (void)printf("psa_hash_operation_init() \r\n");
          (void)printf("psa_hash_setup() \r\n");
          (void)printf("psa_hash_update() \r\n");
          (void)printf("psa_hash_verify() \r\n");
          (void)printf("psa_hash_compare() \r\n");
          psa_hash_test(PSA_ALG_SHA_224, &ret);
          (void)printf("\r\n%s\r\n", ret.info_msg);
          break;

        case '6' :
          /* Test SHA 256 */
          (void)printf("\nPSA API tested : \r\n\r\n");
          (void)printf("psa_hash_operation_init() \r\n");
          (void)printf("psa_hash_setup() \r\n");
          (void)printf("psa_hash_update() \r\n");
          (void)printf("psa_hash_verify() \r\n");
          (void)printf("psa_hash_compare() \r\n");
          psa_hash_test(PSA_ALG_SHA_256, &ret);
          (void)printf("\r\n%s\r\n", ret.info_msg);
          break;

        case '7' :
          /* Test RSA 2048 with SHA 256 algorithm */
          (void)printf("\nPSA API tested : \r\n\r\n");
          (void)printf("psa_key_attributes_init() \r\n");
          (void)printf("psa_set_key_usage_flags() \r\n");
          (void)printf("psa_set_key_algorithm() \r\n");
          (void)printf("psa_set_key_type() \r\n");
          (void)printf("psa_import_key() \r\n");
          (void)printf("psa_asymmetric_encrypt() \r\n");
          (void)printf("psa_asymmetric_decrypt() \r\n");
          (void)printf("psa_destroy_key() \r\n");
          psa_asymmetric_encryption_test(PSA_ALG_RSA_OAEP(PSA_ALG_SHA_256), &ret, 2048);
          (void)printf("\r\n%s\r\n", ret.info_msg);
          break;

        case '8' :
          /* Test DUA USER signature message */
          (void)printf("\nPSA API tested : \r\n\r\n");
          FW_APP_CRYPTO_EcdsaSignMsg(PSA_KEY_ID_ST_DUA_USER);
          break;

        case '9' :
          /* Test key imported by factory its signature message */
          (void)printf("\nPSA API tested : \r\n\r\n");
          FW_APP_CRYPTO_EcdsaSignMsg(0x45);
          break;

        case 'X' :
        case 'x' :
          /* Exit crypto menu */
          exit = 1U;
          break;

        default:
          (void)printf("Invalid Number !\r\n");
          break;
      }

      if (exit == 0U)
      {
        /* Print Main Menu message */
        FW_APP_CRYPTO_PrintMenu();
      }
    }
  }
}

static void FW_APP_CRYPTO_DisplayAead(void)
{
  (void)printf("\nPSA API tested : \r\n\r\n");
  (void)printf("psa_aead_operation_init() \r\n");
  (void)printf("psa_key_attributes_init() \r\n");
  (void)printf("psa_set_key_usage_flags() \r\n");
  (void)printf("psa_set_key_algorithm() \r\n");
  (void)printf("psa_set_key_type() \r\n");
  (void)printf("psa_import_key() \r\n");
  (void)printf("psa_get_key_attributes() \r\n");
  (void)printf("psa_get_key_bits() \r\n");
  (void)printf("psa_get_key_type() \r\n");
  (void)printf("psa_reset_key_attributes() \r\n");
  (void)printf("psa_aead_encrypt() \r\n");
  (void)printf("psa_aead_decrypt() \r\n");
}

static void FW_APP_CRYPTO_EcdsaSignMsg(psa_key_id_t id_key)
{
  psa_status_t psa_status = PSA_ERROR_GENERIC_ERROR;
  psa_key_attributes_t key_attributes = psa_key_attributes_init();
  psa_key_handle_t key_handle = 0;
  psa_algorithm_t alg = PSA_ALG_ECDSA(PSA_ALG_SHA_256);
  const uint8_t block[] = "TEST KEY DUA USER.";
  size_t block_size = sizeof(block) - 1U;
  psa_key_attributes_t key_attributes_pub = psa_key_attributes_init();
  uint8_t signature[PSA_HMAC_MAX_HASH_BLOCK_SIZE] = {0U};
  size_t signature_length = 0x0U;
  uint8_t data[1 + 2 * PSA_BITS_TO_BYTES(256)] = {0};
  size_t data_size = 1 + 2 * PSA_BITS_TO_BYTES(256);
  size_t data_length = 0;

  (void)printf("psa_get_key_attributes() \r\n");
  psa_status = psa_get_key_attributes(id_key, &key_attributes);
  if (psa_status == PSA_SUCCESS)
  {
    (void)printf("Type : 0x%x, bits : 0x%x, lifetime : 0x%x, usage : 0x%x, alg : 0x%x, id : 0x%x  \r\n",
                 key_attributes.type, key_attributes.bits, (int)key_attributes.lifetime, (int)key_attributes.usage,
                 (int)key_attributes.alg, (int)key_attributes.id);
  }
  else
  {
    (void)printf("\rTEST FAILED:%d\r\n", (int)psa_status);
  }

  (void)printf("psa_sign_message() \r\n");
  psa_status = psa_sign_message(id_key, alg, &block[0], block_size, &signature[0], PSA_HMAC_MAX_HASH_BLOCK_SIZE, &signature_length);
  (psa_status == PSA_SUCCESS) ? (void)printf("\rTEST PASSED\r\n") : (void)printf("\rTEST FAILED:%d\r\n", (int)psa_status);

  (void)printf("psa_export_public_key() \r\n");
  psa_status = psa_export_public_key(id_key, &data[0], data_size, &data_length);
  (psa_status == PSA_SUCCESS) ? (void)printf("\rTEST PASSED\r\n") : (void)printf("\rTEST FAILED:%d\r\n", (int)psa_status);

  (void)printf("psa_import_key() \r\n");
  psa_set_key_usage_flags(&key_attributes_pub, PSA_KEY_USAGE_VERIFY_MESSAGE);
  psa_set_key_algorithm(&key_attributes_pub, PSA_ALG_ECDSA(PSA_ALG_SHA_256));
  psa_set_key_type(&key_attributes_pub, PSA_KEY_TYPE_ECC_PUBLIC_KEY(PSA_ECC_FAMILY_SECP_R1));
  psa_set_key_id(&key_attributes_pub, id_key - 1);

  psa_status =  psa_import_key(&key_attributes_pub, &data[0],
                               (1 + 2 * PSA_BITS_TO_BYTES(256)), &key_handle);
  (psa_status == PSA_SUCCESS) ? (void)printf("\rTEST PASSED\r\n") : (void)printf("\rTEST FAILED:%d\r\n", (int)psa_status);
  psa_status = psa_get_key_attributes(key_handle, &key_attributes);
  if (psa_status == PSA_SUCCESS)
  {
    (void)printf("Type : 0x%x, bits : 0x%x, lifetime : 0x%x, usage : 0x%x, alg : 0x%x, id : 0x%x  \r\n",
                 key_attributes.type, key_attributes.bits, (int)key_attributes.lifetime, (int)key_attributes.usage,
                 (int)key_attributes.alg, (int)key_attributes.id);
  }
  else
  {
    (void)printf("\rTEST FAILED:%d\r\n", (int)psa_status);
  }

  (void)printf("psa_verify_message() \r\n");
  psa_status = psa_verify_message(key_handle, PSA_ALG_ECDSA(PSA_ALG_SHA_256),
                                  &block[0], block_size, &signature[0], signature_length);
  (psa_status == PSA_SUCCESS) ? (void)printf("\rTEST PASSED\r\n") : (void)printf("\rTEST FAILED:%d\r\n", (int)psa_status);

  /* Key is imported as persistent key (see lifetime of psa_get_key_attributes()), it is not destroyed at the reset */
  (void)printf("psa_destroy_key() \r\n");
  psa_status = psa_destroy_key(key_handle);
  (psa_status == PSA_SUCCESS) ? (void)printf("\rTEST PASSED\r\n") : (void)printf("\rTEST FAILED:%d\r\n", (int)psa_status);
}

